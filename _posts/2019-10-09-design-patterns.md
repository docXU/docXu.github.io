---
layout:     post
title:      "设计模式之禅"
subtitle:   " \"设计模式能帮助我们提高写码读码的效率\""
date:       2019-10-09 15:25:00
author:     "MattX"
header-img: "img/design-patterns/bg.png"
tags:
    - 设计模式
    - 读书笔记
    - 学习方法
---

> 我用了很短的时间学会写代码，但花费了数十年写好代码。 —— Oracle's nobody.

> 拥抱变化，是程序员在写慢代码时应该考虑的

1. 迪米特法则关键在于让类够独立，和其它类的耦合只发生在方法传递的时候，自己的方法尽量少的public，尽量自己做业务
2. 开闭原则，对扩展开发.对修改关闭，是其它的原则的“抽象类”，即使做不到完全符合，但向这个方向努力就是一个好的架构
![设计原则](/img/design-patterns/dp-principle.png)

---

1. **单例模式**可能由于JVM垃圾回收机制被重置！？  spring如何解决这个问题的呢？ 状态判断？ 单例还是可以用反射创建的。
2. **工厂模式**就是设计一个生成对象子类中心，统一的通过方法get一个新的子对象，用泛型（Class<T> clazz）告知要生产什么

    1. 简单工厂模式，就是简化工厂模式，去掉工厂的抽象类，直接使用一个静态方法用来生产对象。
    2. 复杂工厂模式（多个工厂类）具体的产品（人的子类型）由负责的工厂类去生产，这样会导致产品时，需要实现工厂类和产品类，维护两个类的关系。
    3. 特殊用法：做到可扩展的单例模式，使用复杂工厂模式通过传递工厂类名，由单例工厂反射出单例对象。
    4. 特殊用法：延迟加载的工厂，用Map缓存一个<name,object>的关系，通过name获取对象。
    
3. **抽象工厂模式**和复杂工厂模式的区别是抽象工厂模式的产品是一组互相关联的对象，产品分等级，有几个等级，就应该有几个实现工厂类，而有N个产品族，在抽象工厂中就应该有N个创建方法。

    1. 一个产品族包括同级别的所有产品。
    2. 产品族内的关系（约束）适合在工厂内部实现，高层模块无需关心这个，他只是个工厂。
    3. 缺点是：扩展太差，要加产品族，需修改代码，违反开闭原则
    4. 使用场景：如产生不同操作系统下的编辑器和图片处理器（产品有共同约束：操作系统）
    
4. **模板方法模式**就是将固定逻辑（模板方法）上升到抽象类或父类中，而将一些方法（基本方法）延迟到子类中。使子类可以针对一个算法实现自己的步骤

    1. 在程序中，相同的代码拷贝过两次，就说明设计不合理。
    2. 缺点：场景不合理时会导致阅读障碍。但一些重要复杂的算法可以这么做。以免子类太重。
    3. 完备升级：在父类模板方法中设计钩子方法的使用，子类重写父类的钩子方法，改变算法执行流程。
    4. 在父类中调用子类的换一种思路就是用模板方法模式，将实现延伸到子类中，子类重写protected方法，然后执行类似exucute。
    
5. **建造者模式**（生成器模式Builder）在模板方法模式的基础上，将一个复杂对象的构建与它的表现（最终产品）分离，使得同样的构建过程可以创建不同的表现（实现）

    1. 导演类是封装作用，避免高层模块违背迪米特法则
    2. ![汽车模型](/img/design-patterns/car-models.png)
    3. 它与工厂方法模式最大的不同就是创造者关注的是零件类型和装配工艺，而工厂xx只是注重生产对象，顺序他是不关心的。
    4. 创造者模式最主要的功能是基本方法的调用顺序安排，特点在于组装顺序
    5. 是否可以用链式组装？
    
6. **代理模式**（委托模式）就是和被委托对象实现同一个抽象类（为了获取方法名），委托（封装）一些真实主题角色的逻辑和处理前后工作。p142

    1. Spring AOP、struts表单元素映射到对象 使用的是动态代理。
    2. （普通代理）真实主题角色实现本职工作，高层模块通过依赖注入真实角色给代理类（或者在构造函数里初始化真实对象），代理角色调用真实方法并做一些before和after工作。
    3. （强制代理）高层模块需要通过真实主题对象的getProxy方法获得代理对象去执行本职工作，而无法直接执行真实主题对象的方法。（真实对象的方法实现需要区分调用者（判断this是代理类还是真实类）或者通过限制访问范围实现，如放在一个包里，真实类的实现用包范围，而代理类用public范围），比较内聚但是实现上比较反人类。
    4. 个性代理，一个代理可以实现其它接口，用来做after和before工作（预处理、过滤、消息转发、事后处理），当然也可以代理多个真实角色，角色间的耦合可以发生。
    5. 虚拟代理：类似懒加载，在代理的方法中使用懒初始化的方式，能减少代理对象较多而引起的初始化缓慢的问题。
    6. 动态代理：InvocationHandler接口（JDK）可以做到（使用反射原理获取实现的所有接口方法）优点：代理类与被代理类解耦

        1. 新建委托类（implements InvocationHandler），传递被代理对象。
        2. 创建动态代理类Proxy.newProxyInstance(ClassLoader,Interfaces,InvacationHandler),绑定委托对象
        3. 在委托对象的invoke方法中做本职工作和before和after工作。
        4. 在绑定委托对象的时候也可以做before和after工作（比如AOP的JoinPoint连接点查询并执行）
        5. 不用添加注解的方式使用AOPhttps://blog.csdn.net/theoffspring/article/details/6209199
        6. https://blog.csdn.net/wenbingoon/article/details/22888619
        7. ![动态代理通用类图](/img/design-patterns/dynamic-proxy-UML.png)
        
7. **原型模式**用cloneable接口重写Object.clone()方法，先产生一个包含大量共有信息的类，然后通过拷贝的方式创建对象，而后再个性化类。

    1. 优点：性能优良（内存二进制拷贝，省了构造的过程）
    2. 场景：当new一个对象需要复杂的数据准备和IO操作
    3. 场景2：需要复制一份数据给别的使用者
    4. **注意！clone方法不会拷贝对象里的可变引用成员变量，所以可能导致浅拷贝。需要时自行处理为深拷贝**
    5. 深拷贝也可以使用序列化+反序列化操作，但注意内部变量都要是Serializable对象（除非用transient）最好带一个 serialVersionUID
    
8. **中介者模式**将原本多个对象间蜘蛛网状的依赖关系转换为对象只和中介者依赖(星型结构)

    1. 优点：使原本复杂的依赖关系变得清晰
    2. 缺点：中介者的逻辑爆炸，会变得特别复杂
    3. 场景：MVC框架（C就是中介者）
    
9. **命令模式**将调用者请求参数化为一个命令对象，交由专门的Receiver action

    1. 优点：外部调用者无需知道内部的执行逻辑，只需要发送命令，减少调用者和执行对象的直接依赖
    2. DDD架构
    3. Invoker可以结合职责链模式实现命令族
    4. Command（抽象类）支持扩展, 结合模板方法模式，可以简化实现类代码
    5. Command可以操作多个receiver
    6. 缺点：通过为Command的子类定义具体的名字区分调用者行为，但是这样会带来爆炸式的类增长，需考虑代码复用和逻辑合并
    
10. **职责链模式**和命令模式目的相同，脱离调用者和具体执行逻辑的依赖，请求只需要遍历链路，寻找专职的handler处理即可

    1. 优点：将请求和处理解耦，提高系统灵活性
    2. 每个handler有自己的业务逻辑
    3. handler通过设置下一个handler将请求流转
    4. 调用者只需要在链表头发起请求即可
    5. 缺点：如果链表太长，会影响性能

TODO... 

